<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Демо — Расписание (группа 583)</title>

<!-- pdf.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.113/pdf.min.js"></script>
<!-- tesseract.js (для сканов) -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>

<style>
  html,body { height:100%; margin:0; }
  body {
    background: #000;
    color: #fff;
    font-family: "Segoe UI", Roboto, Arial, sans-serif;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .card {
    width: 100%;
    max-width: 960px;
    padding: 22px;
    box-sizing: border-box;
    border: 1px solid rgba(255,255,255,0.06);
    background: rgba(255,255,255,0.02);
    border-radius: 8px;
  }
  h1 { margin:0 0 12px 0; font-size:20px; text-align:center; }
  .top-row { display:flex; gap:12px; align-items:center; justify-content:center; margin-bottom:12px; flex-wrap:wrap; }
  input[type="text"], input[type="date"], select {
    padding:8px 10px;
    font-size:14px;
    border-radius:6px;
    border: none;
    background: rgba(255,255,255,0.06);
    color: #fff;
    min-width:220px;
  }
  button {
    padding:8px 12px;
    font-size:14px;
    border-radius:6px;
    border:none;
    cursor:pointer;
    background: #0b84ff;
    color:#fff;
  }
  #main {
    margin-top:12px;
  }
  .loading { text-align:center; font-weight:700; padding:20px; }
  .result { white-space:pre-wrap; font-family: monospace; }
  .lessons { margin-top:10px; }
  .lesson { padding:6px 8px; border-bottom:1px solid rgba(255,255,255,0.04); }
  .status { margin-top:12px; font-size:16px; font-weight:700; }
  .small { font-size:13px; color: #ddd; margin-top:6px; }
  .error { color: #ff8080; font-weight:700; }
  .hint { margin-top:10px; font-size:13px; color:#bfbfbf; }
</style>
</head>
<body>
  <div class="card" role="main">
    <h1>Демо: расписание для группы <span id="groupLabel">583</span></h1>

    <div class="top-row">
      <input id="pdfUrl" type="text" placeholder="Ссылка на PDF (Google Drive или прямая ссылка)" style="min-width:420px"
             value="https://drive.google.com/file/d/1kJcV3QfGlvju9_NO6XkXe1_Fy6w0xHSJ/view" />
      <input id="dateInp" type="date" />
      <select id="groupInp" >
        <option>583</option>
        <option>581</option>
        <option>582</option>
      </select>
      <button id="goBtn">Загрузить</button>
    </div>

    <div id="main">
      <div id="stage" class="loading">Загрузка... (нажми «Загрузить» или страница попытается сама)</div>
      <div id="out" class="result" style="display:none"></div>
    </div>

    <div class="hint">
      Примечание: если браузер сообщает ошибку CORS при загрузке PDF — см. примечания внизу страницы. Для надёжной работы загрузи PDF на публичный хост или используй небольшой сервер-прокси.
    </div>
  </div>

<script>
// ========== Конфигурация ==========
// Id группы по умолчанию
const DEFAULT_GROUP = '583';

// Расписание звонков (используем «основную» колонку из присланного фото).
// Это можно расширить по дням недели — сейчас для простоты используем один набор.
// Формат: lessonNumber -> {start:"HH:MM", end:"HH:MM"}
const BELL_SCHEDULE = {
  1: { start: "08:30", end: "09:15" },
  2: { start: "09:25", end: "10:10" },
  3: { start: "10:30", end: "11:15" },
  4: { start: "11:25", end: "12:10" },
  5: { start: "12:40", end: "13:25" },
  6: { start: "13:35", end: "14:20" },
  7: { start: "14:35", end: "15:20" },
  8: { start: "15:30", end: "16:15" },
  9: { start: "16:25", end: "17:10" },
  10: { start: "17:20", end: "18:05" },
  11: { start: "18:15", end: "19:00" },
  12: { start: "19:10", end: "19:55" },
  13: { start: "20:00", end: "20:45" } // если есть
};
// ===================================

const pdfUrlInput = document.getElementById('pdfUrl');
const dateInp = document.getElementById('dateInp');
const groupInp = document.getElementById('groupInp');
const goBtn = document.getElementById('goBtn');
const stage = document.getElementById('stage');
const out = document.getElementById('out');
const groupLabel = document.getElementById('groupLabel');

// поставим дату по умолчанию — сегодня
(function setDefaultDate() {
  const today = new Date();
  const yyyy = today.getFullYear();
  const mm = String(today.getMonth() + 1).padStart(2,'0');
  const dd = String(today.getDate()).padStart(2,'0');
  dateInp.value = `${yyyy}-${mm}-${dd}`;
})();

// helper
function logStage(s){ stage.innerText = s; }
function showResultHtml(html){ out.style.display='block'; out.innerHTML = html; stage.style.display='none'; }
function showError(msg){ stage.innerHTML = `<div class="error">Ошибка: ${msg}</div>`; out.style.display='none'; }

// Попытка получить прямую ссылку для Google Drive view->download
function convertDriveViewToDownload(url) {
  try {
    if(!url) return url;
    // формат https://drive.google.com/file/d/<ID>/view...
    const m = url.match(/\/file\/d\/([a-zA-Z0-9_-]+)/);
    if(m && m[1]) {
      return `https://drive.google.com/uc?export=download&id=${m[1]}`;
    }
    // формат https://drive.google.com/open?id=<ID>
    const m2 = url.match(/[?&]id=([a-zA-Z0-9_-]+)/);
    if(m2 && m2[1]) {
      return `https://drive.google.com/uc?export=download&id=${m2[1]}`;
    }
    // если ссылка уже uc?export=download - вернуть
    if(url.includes('uc?export=download')) return url;
    // иначе вернуть как есть (может быть прямая ссылка)
    return url;
  } catch(e){
    return url;
  }
}

async function fetchArrayBufferWithFallback(url) {
  // попробуем напрямую
  let lastErr = null;
  try {
    const resp = await fetch(url);
    if(!resp.ok) throw new Error('HTTP ' + resp.status);
    return await resp.arrayBuffer();
  } catch (e) {
    lastErr = e;
  }
  // если google drive view link, попробуем преобразовать
  const conv = convertDriveViewToDownload(url);
  if(conv !== url) {
    try {
      const resp = await fetch(conv);
      if(!resp.ok) throw new Error('HTTP ' + resp.status);
      return await resp.arrayBuffer();
    } catch(e) {
      lastErr = e;
    }
  }
  // финальный отказ
  throw new Error('Не удалось загрузить PDF напрямую. Браузер возможно блокирует CORS. ' + (lastErr? lastErr.message : ''));
}

// Извлекаем текст: сначала pdf.js.getTextContent, если пусто — рендерим страницу и OCR
async function extractTextFromPdfBuffer(buffer, onProgress) {
  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.113/pdf.worker.min.js';
  const loadingTask = pdfjsLib.getDocument({ data: buffer });
  const pdf = await loadingTask.promise;
  let fullText = '';
  for (let p = 1; p <= pdf.numPages; p++) {
    if(onProgress) onProgress(`Парсинг страницы ${p}/${pdf.numPages}...`);
    const page = await pdf.getPage(p);
    // 1) пробуем текстовый слой
    let pageText = '';
    try {
      const tc = await page.getTextContent();
      pageText = tc.items.map(i => i.str).join(' ').trim();
    } catch(e) {
      pageText = '';
    }
    // 2) если текст не найден или очень короткий - делаем OCR
    if(!pageText || pageText.length < 40) {
      if(onProgress) onProgress(`Текст не найден на странице ${p}. Делается OCR (это может занять время)...`);
      const viewport = page.getViewport({ scale: 2.0 });
      const canvas = document.createElement('canvas');
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);
      const ctx = canvas.getContext('2d');
      await page.render({ canvasContext: ctx, viewport }).promise;
      // OCR
      try {
        const dataUrl = canvas.toDataURL('image/png');
        const ocrResult = await Tesseract.recognize(dataUrl, 'rus+eng', {
          logger: m => {
            if(onProgress && m.status && m.progress) {
              onProgress(`OCR: ${m.status} ${(m.progress*100).toFixed(0)}%`);
            }
          }
        });
        pageText = ocrResult.data.text || '';
      } catch(ocrErr) {
        // если OCR упал — всё равно собираем пустую строк
        pageText = '';
      }
    }
    fullText += '\n' + pageText;
  }
  return fullText;
}

// Преобразуем дату input -> ключ dd.mm
function dateInputToKey(val) {
  if(!val) {
    const d = new Date();
    return String(d.getDate()).padStart(2,'0') + '.' + String(d.getMonth()+1).padStart(2,'0');
  }
  const d = new Date(val);
  const dd = String(d.getDate()).padStart(2,'0');
  const mm = String(d.getMonth()+1).padStart(2,'0');
  return `${dd}.${mm}`;
}

// Найти блок текста для нужной даты: ищем все вхождения dd.mm и берём ближайший блок
function extractBlockForDate(fullText, dateKey) {
  // нормализуем
  const text = fullText.replace(/\r/g,'\n');
  // ищем позиции всех дат формата d[.]m или dd.mm.yyyy
  const dateRegex = /\b([0-3]?\d)[\.\/-]([01]?\d)(?:[\.\/-](\d{2,4}))?\b/g;
  const matches = [];
  let m;
  while((m = dateRegex.exec(text)) !== null) {
    const key = m[1].padStart(2,'0') + '.' + m[2].padStart(2,'0');
    matches.push({ idx: m.index, key });
  }
  if(!matches.length) {
    // если дат не найдено — возвращаем весь текст
    return text;
  }
  // найдём match с key == dateKey
  const found = matches.find(x => x.key === dateKey);
  if(found) {
    const start = found.idx;
    // конец — индекс следующей даты или end
    const next = matches.find(x => x.idx > start);
    const end = next ? next.idx : text.length;
    return text.slice(start, end);
  }
  // если точной даты нет — попробуем ближайшую по позиции (например только 06.08 встречается)
  // попробуем найти any match for day/month equal ignoring year
  const close = matches[0];
  return text.slice(close.idx, (matches[1]? matches[1].idx: text.length));
}

// Внутри блока ищем группу (например "583"), и извлекаем соседующий по строкам текст
function extractGroupBlock(blockText, groupStr) {
  // разобьём по строкам
  const lines = blockText.split(/\n/).map(l=> l.trim()).filter(l=> l.length>0);
  // найдём индекс строки, где встречается группа
  let idx = -1;
  for(let i=0;i<lines.length;i++){
    if(new RegExp('\\b' + groupStr + '\\b','i').test(lines[i])) { idx = i; break; }
  }
  if(idx === -1) {
    // иногда в таблицах OCR ломает пробелы: попробуем поиск в блоке как подстроки
    const pos = blockText.indexOf(groupStr);
    if(pos>=0) {
      // экстракт контекста +- 300 символов
      const start = Math.max(0, pos-200);
      const end = Math.min(blockText.length, pos+400);
      return blockText.slice(start,end);
    }
    return '';
  }
  // собираем несколько строк вокруг найденной: -2..+6
  const from = Math.max(0, idx-2);
  const to = Math.min(lines.length, idx+6);
  return lines.slice(from,to).join('\n');
}

// Парсинг уроков: ищем шаблон "1 урок ...", "1. ...", "1  ...", либо просто номера в колонке слева
function parseLessonsFromGroupBlock(groupBlockText) {
  if(!groupBlockText) return [];
  const text = groupBlockText.replace(/\t/g,' ').replace(/\s{2,}/g,' ');
  const lessons = [];

  // Попробуем сначала шаблон: "1 урок ...", "1 урок - Математика"
  const rx1 = /(\b[1-9]|1[0-3])\b\s*(?:урок|ур|:|-|–|—|\.)?\s*([^\n\r]+)/gi;
  let m;
  let foundAny = false;
  while((m = rx1.exec(text)) !== null) {
    const num = Number(m[1]);
    let subj = (m[2] || '').trim();
    if(subj) {
      // иногда в конце есть фамилия учителя -> постараемся отделить: если есть точка после буквы (инициалы), можно убрать часть
      // оставим всё, но позже можно разделить по двойному пробел или таб
      lessons.push({ number: num, raw: subj });
      foundAny = true;
    }
  }
  if(foundAny) {
    // упорядочим по номеру
    lessons.sort((a,b)=> a.number - b.number);
    return lessons;
  }

  // Если не нашли, попробуем найти колонку из отдельных цифр в левой части: ищем строки, содержащие только цифру (или цифру в начале)
  const lines = text.split(/\n/).map(l=>l.trim()).filter(Boolean);
  for(let i=0;i<lines.length;i++){
    const L = lines[i];
    // ищем номер урока в начале
    const m2 = L.match(/^\s*([1-9]|1[0-3])\b[).]?\s*(.*)/);
    if(m2) {
      const num = Number(m2[1]);
      let rest = (m2[2] || '').trim();
      // если rest пустой, возможно предмет на следующей строке
      if(!rest && lines[i+1]) rest = lines[i+1].trim();
      lessons.push({ number: num, raw: rest });
    } else {
      // может быть просто строка с числом в колонке (OCR): берем все числа в строке
      const allNums = L.match(/\b([1-9]|1[0-3])\b/g);
      if(allNums && allNums.length) {
        for(const n of allNums) lessons.push({number: Number(n), raw: L});
      }
    }
  }
  // удалим дубликаты по номеру, оставим первое встречное
  const uniq = [];
  const seen = new Set();
  for(const it of lessons) {
    if(!seen.has(it.number)) { uniq.push(it); seen.add(it.number); }
  }
  // сорт
  uniq.sort((a,b)=> a.number - b.number);
  return uniq;
}

// Сопоставляем с расписанием звонков и возвращаем массив с start/end
function mergeWithBells(lessons) {
  const merged = lessons.map(l => {
    const bell = BELL_SCHEDULE[l.number] || null;
    return {
      number: l.number,
      subjectRaw: l.raw || '',
      start: bell ? bell.start : null,
      end: bell ? bell.end : null
    };
  });
  return merged;
}

// Вспомог: превратить "HH:MM" в Date на сегодняшней дате
function timeStrToDateToday(t) {
  if(!t) return null;
  const [hh,mm] = t.split(':').map(s => parseInt(s,10));
  const d = new Date();
  d.setHours(hh, mm, 0, 0);
  return d;
}

// Вычисляем текущий статус и возвращаем объект
function computeCurrentStatus(mergedLessons) {
  const now = new Date();
  for(const l of mergedLessons) {
    if(l.start && l.end) {
      const s = timeStrToDateToday(l.start);
      const e = timeStrToDateToday(l.end);
      if(now >= s && now < e) {
        // нашли текущий урок
        const untilEndMs = e - now;
        const next = mergedLessons.find(x => timeStrToDateToday(x.start) > s);
        return { mode:'inLesson', current:l, untilEndMs, next };
      }
    }
  }
  // если сейчас до первого урока
  const upcoming = mergedLessons.find(l => l.start && (timeStrToDateToday(l.start) > new Date()));
  if(upcoming) {
    const untilStartMs = timeStrToDateToday(upcoming.start) - new Date();
    // найдем предыдущий закончившийся
    const prev = [...mergedLessons].reverse().find(l => l.end && (timeStrToDateToday(l.end) <= new Date()));
    return { mode:'beforeLesson', next: upcoming, untilStartMs, prev };
  }
  return { mode:'finished' };
}

function msToHuman(ms) {
  if(ms < 0) ms = -ms;
  const s = Math.floor(ms/1000);
  const m = Math.floor(s/60) % 60;
  const h = Math.floor(s/3600);
  const secs = s % 60;
  return (h? (h + 'ч ') : '') + (m? (m + 'м ') : '') + secs + 'с';
}

// Рисуем результат в интерфейсе и запускаем обновление таймеров
let timerInterval = null;
function renderMergedAndStatus(mergedLessons) {
  if(timerInterval) { clearInterval(timerInterval); timerInterval = null; }
  function draw() {
    const now = new Date();
    let html = '';
    html += `<div class="small">Текущая дата (по устройству): <b>${dateInputToKey(dateInp.value)}</b></div>`;
    html += `<div class="lessons">`;
    for(const l of mergedLessons) {
      html += `<div class="lesson"><b>${l.number} урок</b> ${l.start?`(${l.start}—${l.end})`: '(время не найдено в звонках)'} — ${escapeHtml(l.subjectRaw)}</div>`;
    }
    html += `</div>`;

    const status = computeCurrentStatus(mergedLessons);
    html += `<div class="status">`;
    if(status.mode === 'inLesson') {
      html += `Сейчас идёт <span style="color:#a3ff9a">${status.current.number} урок</span> — ${escapeHtml(status.current.subjectRaw)}.<br>`;
      html += `Осталось: <span style="color:#a3ff9a">${msToHuman(status.untilEndMs)}</span><br>`;
      if(status.next) html += `Следующий: ${status.next.number} (${status.next.start}) — ${escapeHtml(status.next.subjectRaw)}.`;
    } else if(status.mode === 'beforeLesson') {
      html += `Сейчас перемена/до занятий. Следующий: <b>${status.next.number} (${status.next.start})</b> — ${escapeHtml(status.next.subjectRaw)}.<br>`;
      html += `До начала: <span style="color:#fffb7f">${msToHuman(status.untilStartMs)}</span>`;
    } else {
      html += `Занятия не обнаружены или уже закончились на выбранную дату.`;
    }
    html += `</div>`;

    showResultHtml(html);
  }

  draw();
  timerInterval = setInterval(draw, 1000);
}

function escapeHtml(s) {
  if(!s) return '';
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

// ========== Основной рабочий поток ==========
async function runFullParse() {
  stage.style.display = 'block';
  out.style.display = 'none';
  out.innerHTML = '';
  const url = pdfUrlInput.value.trim();
  const group = (groupInp.value || DEFAULT_GROUP).trim();
  groupLabel.innerText = group;

  // date key
  const dateKey = dateInputToKey(dateInp.value);

  try {
    logStage('Подготовка к загрузке PDF...');
    const downloadUrl = convertDriveViewToDownload(url);
    logStage('Попытка загрузить PDF...');
    const buffer = await fetchArrayBufferWithFallback(downloadUrl);
    logStage('PDF загружен. Извлечение текста (pdf.js / OCR)...');

    const text = await extractTextFromPdfBuffer(buffer, (prog)=> logStage(prog));
    logStage('Анализ текста. Ищем дату ' + dateKey + ' и группу ' + group + ' ...');

    // ищем блок для даты
    const dateBlock = extractBlockForDate(text, dateKey);
    if(!dateBlock || dateBlock.trim().length < 10) {
      // если не нашли блок с датой — попробуем дать пользователю весь документ для отладки
      showError('Не удалось найти блок с датой ' + dateKey + '. Возможно формат даты в PDF иной. Ниже — первые 2000 символов документа для отладки.');
      out.style.display = 'block';
      out.innerText = text.slice(0,2000) + '\n\n...';
      return;
    }

    // внутри блока ищем группу
    const grpBlock = extractGroupBlock(dateBlock, group);
    if(!grpBlock || grpBlock.trim().length < 5) {
      showError('Не найден блок с группой ' + group + ' в разделе даты ' + dateKey + '. Проверьте правильность группы или формат PDF.');
      return;
    }

    // парсим уроки
    const lessons = parseLessonsFromGroupBlock(grpBlock);
    if(!lessons || lessons.length === 0) {
      showError('Не удалось распознать уроки рядом с группой ' + group + '. Содержимое найденного блока:\n\n' + grpBlock.slice(0,2000));
      return;
    }

    // сопоставляем с звонками
    const merged = mergeWithBells(lessons);

    // выводим
    renderMergedAndStatus(merged);
    logStage('Готово — расписание получено и отображается ниже.');
  } catch(err) {
    showError(err.message || String(err));
    console.error(err);
  }
}

// запуск по кнопке
goBtn.addEventListener('click', runFullParse);

// автоматический запуск при загрузке страницы
window.addEventListener('load', ()=> {
  // небольшая задержка чтобы UI успел показать "Загрузка..."
  setTimeout(runFullParse, 300);
});

/* ================== Примечания по CORS и проблемам загрузки ==================
1) Google Drive:
   - Если у тебя ссылка выглядит как:
       https://drive.google.com/file/d/<FILE_ID>/view
     то код пытается автоматически преобразовать её в:
       https://drive.google.com/uc?export=download&id=<FILE_ID>
   - Тем не менее Google Drive иногда возвращает страницу со скриптами и блокирует прямой доступ из браузера (CORS).
     В этом случае браузер выдаст ошибку в консоли вида CORS или отказ по политике.

2) Решения при ошибке CORS:
   a) Самый простой — загрузить PDF на публичный сервер (например: GitHub Pages, любой публичный хост) и поставить прямую ссылку.
   b) Поставить небольшой сервер-прокси (Node.js + express) рядом с твоим сайтом, который скачивает PDF и отдаёт его клиенту.
      Пример простого прокси (Node):
        const express = require('express');
        const fetch = require('node-fetch');
        const app = express();
        app.get('/proxy', async (req,res)=> {
          const url = req.query.url;
          const r = await fetch(url);
          const buf = await r.buffer();
          res.set('Content-Type','application/pdf');
          res.send(buf);
        });
      Тогда в интерфейсе укажешь: /proxy?url=<encoded original url>

3) Отладка:
   - Если парсер не находит дату/группу — открой DevTools -> Console, и посмотри в выводе ошибок.
   - Также можно временно вывести `text` (первые 3000 символов) чтобы понять, как OCR/pdf.js видит документ.

============================================================================= */
</script>
</body>
</html>